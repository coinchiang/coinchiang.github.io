# 面向对象的特征

- 封装
- 继承
- 多态
- 抽象

# 类的基本要素

 ```java
[访问权限修饰符] 类名 {
     成员变量
     构造方法（有参、无参）
     成员方法（getters、setters）
 }
 ```

# 局部变量和成员变量

> 局部变量是指定义在方法中的变量

- 成员变量存储在**堆**内存中，局部变量存储在**栈**内存中
- 成员变量的生命周期与对象相同，局部变量的生命周期与方法相同
- 当局部变量和成员变量重名时，局部变量优先与成员变量（**就近原则**）

# 值传递和引用传递

> 实质上，数据的传递方式是复制

向方法传入基本数据类型的数据，方法得到的是该数据的副本；向方法传入引用数据类型的数据，方法得到的是该数据地址的副本。二者没有本质区别。

# 匿名对象

没有名字的对象称为匿名对象，该对象的使用具有一次性，也不需要有名字。

```java
PersonTools.showInfo(new Student());
```

# 构造方法

```java
访问权限修饰符 类名() {
    ...
}
```

- 默认存在无参构造方法，一旦我们添加构造方法，则默认无参构造方法将消失

- 通过`this`关键字可以实现构造方法相互调用，但是只能放置在构造方法的第一行

  ```java
  public class Student {
      private String name;
      private String studentID;
      private String gender;
      //无参构造方法
      public Student() {
          
      }
      //有参构造方法
      public Student(String name, String studentID) {
          this.name = name;
          this.studentID = studentID;
      }
      //重载
      public Student(String name, String studentID, String gender) {
          this(name, studentID);
          this.gender = gender;
      }
  }
  ```
  
# 封装的概念

将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问


# static

> `static`修饰的内容属于类而非对象

`Math.random()`

- 访问静态成员的方式

  ```java
  Class.method();
  Class.field;
  ```

- 静态环境下不能出现`this`和`super`关键字

- 工具类中常用`static`

# 代码块

## 静态代码块

>静态代码块：在类中使用static修饰,并使用`{}`括起来的代码片段，用于**静态变量**的初始化或对象创建前的环境初始化，**只会被执行一次（第一次加载此类时执行）**，静态代码块优先于构造代码块执行

## 构造代码块

> 在类中没与任何的前缀或后缀,并使用`{}`括起来的代码片段

```java
public class Client {
    {	//构造代码块
        System.out.println("执行构造代码块");
    }

    public Client() {
        System.out.println("执行无参构造函数");
    }

    public Client(String string) {
        System.out.println("执行有参构造函数");
    }
}
```

代码块不具有独立执行的能力,编译器会把构造代码块插入到**每个**构造函数的最前端

```java
public class Client {

    public Client() {
        System.out.println("执行构造代码块");
        System.out.println("执行无参构造函数");
    }

    public Client(String string) {
        System.out.println("执行构造代码块");
        System.out.println("执行有参构造函数");
    }
}
```

由于是插入到构造函数的的前面,自然在通过`new`关键字生成一个实例的时候会先执行构造代码块，然后再执行其他代码（**构造代码块不是在构造函数之前运行,而是依托于构造函数**）。

所以构造代码块具有如下特性：

1. 在每个构造函数中都运行
2. 在构造函数中它会首先运行

应用于：

1. 初始化**实例**变量

   > 如果每个构造函数都需要初始化变量,即可通过构造代码块来实现.从而取代在每个构造函数调用初始化实例变量的方法

2. 初始化**实例**环境

   > 一个对象必须在适当的场景下才能存在,如果没有适当的场景,则就需要在创建对象的时候创建此场景

### 构造代码块足够聪明

```java
//用构造代码块做对象计数器
public class Client {
    public static int count = 0;
    {
        count++;
    }

    public Client() {

    }

    public Client(int i) {
        this();
    }

    public Client(String string) {
    }

    public static void main(String[] args) {
        new Client();
        new Client(1);
        new Client("1");
        System.out.println(Client.count);
    }
}
```

这个代码真的达到我们预期的效果：结果是`3`。你可能会对`this()`产生质疑。

Java编译器是足够聪明的。这是因为，在插入到每个构造函数中的时候，有个例外，就是如果遇到`this()`方法（也就是构造函数调用自身其他的构造函数时）不插入构造代码块 。

那为什么编译器这么聪明呢？这是因为构造代码块的出现本就是为了提取构造函数的共同量，减少各个构造函数的代码而产生的。

灵活适当的使用构造代码块会让你的代码更加的简约和清晰。代码的质量自然会高很多。

最后还有一点需要注意的,千万不要认为`this()`是特殊情况,那`super()`也会类似处理。其实不会，在构造代码块的处理上，`super()`方法没有任何特殊的地方。编译器只是把构造代码块插入到 `super()`方法**之后**执行而已。

##  静态代码块和构造方法的执行顺序

`父类`

```java
package com.xanadu.exercise;

public class UntitledFather {
	private String familyName;
	static String country;
	
	public UntitledFather() {
		System.out.println("执行父类构造方法");
	}
	
	static {
		country = "China";
		System.out.println("执行父类静态代码块");
	}
}
```

`子类`

```java
package com.xanadu.exercise;

public class UntitledSon extends UntitledFather {
	public UntitledSon() {
		System.out.println("执行子类的构造方法");
	}
	
	static {
		System.out.println("执行子类的静态代码块");
	}
}
```

`测试类`

```java
package com.xanadu.exercise;

public class TestForUntitled {
	public static void main(String[] args) {
		UntitledSon u1 = new UntitledSon();
		UntitledSon u2 = new UntitledSon();
	}
}
```

`输出`

```java
执行父类静态代码块
执行子类的静态代码块
执行父类构造方法
执行子类的构造方法
执行父类构造方法
执行子类的构造方法
```

# package import

> `package`的本质就是文件夹

1. 在同一个包下面的类可以直接使用 

2. 在Java中`java.lang`包下面的所有的类可以直接使用

3. 除了以上两种其他类的使用都必须通过`import`关键字来导入才可以使用

4. 如果一个类没有包名，那么该类将不会被其他包所导入

5. 包的声明必须出现在第一句

6. `package`语句在一个java文件中只能出现一句

7. 如果一个类文件需要使用到两个包下同名的类，一个通过`import`来导入，另一个通过代码中全路径指定的方式来实现

   ```java
   com.xanadu.oop.Student student = new com.xanadu.oop.Student();
   ```

# 继承

```java
class Student extends Perosn() {
	...
}
```

1. 继承是对一批类的抽象，类是对一批对象的抽象 

2. Java中只支持单继承，不支持多继承，但是支持多层继承

3. 子类可以继承父类`private`修饰的属性和方法，但是不可见

   > `super`是不能访问私有的成员变量的，可以通过访问对应的公有方法实现

   ![image-20220203220419259](img\继承private属性.png)

4. 子类不可以继承父类构造方法

5. 任何一个构造方法都默认的会在构造方法的第一句上写上`super()`访问父类的无参构造方法，目的是初始化父类的成员变量

6. `super()`和`this()`方法构造方法都必须出现在构造方法的第一句，`this()`和`super()`在方法构造方法的时候，不能共存

   ![image-20220203221536404](img\this和super.png)

7. `static`的上下文都是不能出现`this`和`super`的，因为`static`是**类**的

# 访问权限修饰符

> `public` `protected` `[default]` `private`

## 修饰的元素

- 类：
  - 只有`public`、`abstract`和`final`能够修饰，或者不加（`default`）
  - `private`和`protected`可以修饰*内部类*
- 成员变量
- 成员方法

## 权限的范围

按由宽到严的顺序：

1. `public`修饰的成员对一切类可见 
2. `protected`修饰的成员同包下面都可见，不同包下只有**子类**可见
3. `default`修饰的成员仅同包下可见
4. `private`修饰的成员仅对本类可见

# 方法的重写

> 如果从父类继承的方法不能满足子类的需求的情况下，可以对其进行改写，称为方法的重写

方法的重写的规则

- 方法名称相同
- 参数列表相同
- 返回值类型相同或者是其**子类**
- 访问权限修饰符**不严于**父类

# final

- final修饰类，该类不能被继承

- 修饰变量：用来表示常量，标识符应全大写，单词间用`_`分隔

  - 成员变量：必须在声明时赋值，常与static连用

    ```java
    final static String NAME = "aaa"
    ```

  - 局部变量：可以在使用之前赋值

- 修饰方法：子类不能重写该方法

# 多态

## 多态的实现：

- 必须存在继承
- 必须存在重写[?]
- 必须有父类引用指向子类对象

```java
Person p = new Student();
```

##  多态访问成员的特点

- 成员变量：在访问的时候是直接访问父类的属性
- 成员方法：若存在重写，则会访问子类中重写的方法
- 构造方法：ops，想想构造方法是干什么的吧
- 静态成员：因为静态成员是属于类的，不能被继承。而且静态方法也不应该直接通过实例去调用。
	
## 多态的应用

- 使用父类作为方法的形参：使用父类作为一个方法的形参，则可以传入父类对象，也可以传入其子类
- 使用父类作为方法的返回值

## 向下转型

多态中无法调用子类特有的属性和方法，需要向下转型

```java
Person p = new Student();

if (p instanceof Student) {	//为规避类型转换异常
	Students s = (Student)p;
	s.study();
}
```

# 抽象类

```java
//抽象类
abstract class AbsPerson {
	//抽象方法
	public abstract void study(Subject s)；
	//抽象方法没有方法体
}
```

抽象方法**必须**定义在抽象类中，抽象类中可以没有抽象方法，抽象类可以有非抽象方法。

 > 没有抽象方法的抽象类的意义？ 
 > 抽象类不能被实例化
 
 抽象类不能被实例化，因为其该为子类服务
 
## 抽象类的子类
 
 - 实现父类中**所有**的抽象方法
 - 将自身作为抽象类
 	```java
 	abstract class Man {
 		public abstract void teaching();
 		public abstract void speak();
 	}
 	
 	abstract class Adult extends Man {
 		public void speak() {
 			...
 		}
 	}
 	
 	class Teacher extends Adult {
 		public void teaching() {
 			...
 		}
 	}
 	```
> 抽象类中可以包含哪些内容?
> 成员变量，成员方法，常量，构造方法，静态方法，代码块，静态代码块都可以。

## static final private 都不能修饰抽象方法

- static是属于类的，为了方便调用。而abstract方法就是为了给子类重写的，都没方法体。
- final修饰的方法不能被重写
- private修饰的方法不能被继承

## 抽象类的服务性

1. 抽象类的所有的抽象方法都是用来给子类重写的
2. 抽象类的所有的非抽象方法也是用来给子类使用的
3. 抽象类的构造方法是用来给子类初始化父类继承过来的成员
4. 抽象类的成员变量也是用来给子类使用的

# 接口

 接口是抽象方法和常量的集合，JDK1.8之后接口中可以包含静态方法和默认方法。

## 语法规则

```java
interface interfacename {
	常量；// 都会默认省略public static final，一般变量都大写
	抽象方法；// 都会默认省略public abstract
}
```

```java
interface IMan {
	// 静态方法
	public static void sleep() {
		...
	};
	// 默认方法
	default void run() {
		...
	}
}
```

## 实现接口

```java
class Student implements IMan {
	@Override
	...
}
```

作为接口的实现类：

- 实现接口的所有抽象方法
- 定义为抽象类或者接口

## 接口多实现、多继承

```java
public class User implements IStudent, IPolice {
	@Override
}

public interface Student extends IPerson, IDoctor {
	
}
```

## 接口中存在的多态

```java
Iperson peroson = new Person();
```

## 继承和接口的使用场景

设计一个非常复杂而又无法实现的类时可以用继承

重新开始编写一些简单的功能或者制定一些标准的时候用接口

开发中一般采用面向接口编程，抽象类是模板，接口是规范

# 多态的应用

多态的两种形式：

- 使用父类作为方法的形参
- 使用父类作为方法的返回值

## 多态作为形参

	- 普通类：当形参为普通类时，可以传递该类的对象/匿名对象/子类
	- 抽象类：当形参为抽象类时，可以传递该类的子类对象/子类匿名对象
	- 接口：当形参为接口时，可以传递该接口的实现类对象/实现类匿名对象

## 多态作为返回值

	- 普通类：方法返回值为普通类时，实际返回的就是该类的对象，可以用该类的对象类接收
	- 抽象类：方法返回值为抽象类时，实际返回的就是该类的子类对象，可以使用该抽象类/该类的子类（强制类型转换）来接收
		```java
			public AbsStudent getAbsStudent() {
				return new AbsStudent() {}; // 内部类
			}
		```
	- 接口：方法返回值为接口时，实际返回的是该接口的实现类对象，可以使用该接口/该实现类（类型强制转换）来接收
	
## 链式调用

当方法的返回值是引用类型时，可以使用链式调用

```java
interface IPerson {
	IPerson sleep();
	IPerson run();
	IPerson eat();
}

class Person impelments IPerson {
	public IPerson sleep() {
		return this;
	}
	
	public IPerson run() {
		return this;
	}
	
	public IPerson eat() {
		return this;
	}
}

public static void main(String[] args) {
	IPerson p = new Person();
	IPerson p = p.eat().sleep().run().eat().run().sleep();
}		
```

# 内部类

> Java中不能被实例化的类型：
>
> * 抽象类
> * 接口
> * 所有的构造方法都被private修饰的类型
> * 内部类不能被外界直接实例化

**内部类**：定义在类的内部的类

## 内部类的特点

- 内部类可以直接访问外部类的所有的成员
- 外部类如果要访问内部类成员，必须创建内部类对象来实现
- 内部类编译成的class文件命名为：外部类$内部类.class
- 要访问内部类的成员是非常麻烦的，而且造成程序耦合性增强，可读性降低，所以内部类慎用

## 成员内部类

在外部类中定义一个成员内部类，这个内部类和成员方法是同级的

```java
class Outter {
	...
	class Inner {
		...
	}
}
```

### 外部获取内部类对象

- 内部类非私有：`Outter.Inner in = new Outter().new Inner();`

- 内部类私有：内部类作为外部类的成员是可以用private修饰的，如此外界是无法直接获取该对象的。可以使用getter/setter来处理
	```java
		public class Outter {
			...
			private class Inner {
				...
			}
			
			public void getInner() {
				return new Inner();
			}
		}
	```
	
### 变量作用域

```java
public class Outter {
	int age; // 1
	class Inner {
		int age; // 2
		
		public void showAge() {
			int age; //3
			System.out.println(age); // 3
			System.out.println(this.age); // 2
			System.out.println(Outter.this.age); // 1
		}
	}
}
```

## 局部内部类

局部内部类可以理解为和局部变量同级的内部类

```java
class Outter {
	int num1 = 20;
	/**
	* 在JDK1.8之后 把局部内部类中使用的外部方法的局部变量默认的提升为 final
	* 在JDK1.8之前 这里会强制要求我们将 局部变量声明为final类型
	*/
	public void show() {
		int num = 30;
		// 定义一个局部内部类
		class Inner {
			public void info() {
				System.out.println("inner info ..." + num);
			}
		}
		// 我们要使用内部类对象 调用其中的方法才会执行
		Inner in = new Inner();	// 注意顺序执行，此句放Inner定义之上就不行
		// num = 50;
		in.info();
		System.out.println(num);
	}
}
```

## 静态内部类

被static修饰的成员内部类就是静态内部类

```java
public class Test {
	public static void main(String[] args) {
		// 1.获取外部内对象
		Outter out = new Outter();
		//out.show();
		// 2.获取静态内部类对象
		// Outter.Inner in = new Outter().new Inner();
		// Outter.Inner in = Outter.(new Inner());
		Outter.Inner in = new Outter.Inner();
		Outter.name = "";
		Outter.show();
	}
}

class Outter{
	public static String name = "张三";
	public static void show(){
		System.out.println(name);
	}
	/**
	* 定义的一个静态内部类
	*/
	static class Inner{
		public static String name="李四";
		
		public int age = 20;
		
		public void info1(){
			System.out.println(age);
		}
		
		public static void info2(){
			System.out.println("内部类:" + name);
		}
	}
}
```

静态内部类相比于成员内部类来说简化了方法方式，好处同样是提高了类的安全性。

静态内部类的特点：
- 本身还是一个class，所以内部成员和普通类没有区别
- 静态内部类不能获取外部类中的非静态属性和方法
- 在外部类中要获取内部类对象直接实例化即可
	`Outter.Inner in = new Outter.Inner();`
	
##  匿名内部类

