# 数组

## 冒泡排序

```java
public static void bubbleSort(int[] array) {
    for (int i = 0; i < array.length - 1; i++) {
        boolean isOrdered = true;
        for (int j = 0; j < array.length - 1 - i; j++) {
            if (array[j] > array[j + 1]) {
                int t = array[j];
                array[j] = array[j + 1];
                array[j + 1] = array[j];
                isOrdered = false;
            }
        }
        if (isOrdered) {
            break;
        }
    }
}
```

## 选择排序

```java
public static void selectionSort(int[] array) {
    for (int i = 0; i < array.length - 1; i++) {
        for (int j = i + 1; j < array.length; j++) {
            if (array[i] > array[j]) {
                int t = array[i];
                array[i] = array[j];
                array[j] = t;
            }
        }
    }
}
```

## 效率对比

> `System.currentTimeMillis()`	返回值类型为`long`
>
> the difference, measured in milliseconds, betweenthe current time and midnight, January 1, 1970 UTC.

```java
public class Time {
	/**
	 * 对比冒泡和选择 排序的效率
	 * @param args
	 */
	public static void main(String[] args) {
		int[] array = new int[1000];
		
		long startTime = System.currentTimeMillis();
        for (int j = 0; j < 10000; j++) {
            for (int i = 0; i < array.length; i++) {
                array[i] = (int)(Math.random() * 1000 + 1);
            }
            //bubbleSort(array);
            selectionSort(array);
        }
		long endTime = System.currentTimeMillis();
		System.out.println(endTime - startTime);
	}
}
```

|                 | 1     | 2     |
| --------------- | ----- | ----- |
| `bubbleSort`    | 1802  | 2193  |
| `selectionSort` | 14643 | 14594 |

> `Arrays.sort()` 是一种比传统快速排序更快的快速排序

## 数组扩容

```java
public static int[] expandArray(int[] array, int input) {
	int[] arrayNew = new int[array.length + 1]; 
		
	for (int i = 0; i < array.length; i++) {
			arrayNew[i] = array[i];
	}
	arrayNew[array.length] = input;
	return arrayNew;
}
```

## 二分查找

*使用二分查找时，操作数组要先排好序*

```java
public static int binarySearch(int[] array, int num) {
    int min = 0;
    int max = array.length - 1;
    int mid = (max + min) / 2;
    int index = -1;
    while (max != min) {
        if (num > array[mid]) {
            min = mid + 1;
        } else if (num < array[mid]) {
            max = mid - 1;
        } else {
            index = mid;
            break;
        }
        mid = (max + min) / 2;
    }
    if (index == -1) {
        index = array[max] == num ? max : index;
    }
    return index;
}
```

更好的版本

```java
public static int binarySearch(int[] array, int num) {
    int min = 0;
    int max = array.length - 1;
    int mid = (max + min) / 2;
    
    while (array[mid] != num) {
        if (num > array[mid]) {
            min = mid + 1;
        } else if (num < array[mid]) {
            max = mid - 1;
        }
        if (min > max) {
            return -1;
        }
        mid = (max + min) / 2;
    }
    return mid;
}
```

> 编写顺序查找的方法`public static int[] ordinalSearch(int data[],int key)`，要求该方法返回一个数组（如果`key`存在，数组中各元素的值分别为关键字`key`在原数组`data`中的各下标；如果`key`不存在，则返回一个长度为`1`的数组，数组元素为`-1`）。
>
> 基本过程思路：
>
> 1. 先扫描数组`data`，统计数组中`key`的个数`n`
>
> 2. 如果`n`为`0`，直接返回一个数组元素为`－1`的数组；否则的话定义一个数组`int index[]=new int[n]`，再扫描数组`data`，把数组中值为`key`的各个元素的下标保存到数组`index`中，最后返回数组`index`

## foreach循环

 语法

```java
for (元素类型 元素变量 : 遍历对象) {
    使用元素变量的循环体
}
```

遍历输出数组元素

```java
for (int i : array) {
    System.out.println(i);
}
```

## Arrays工具类

`import java.util.Arrays`

```java
import java.util.Arrays;
public class ArrayDemo06 {
/**
* Arrays工具类介绍
*
* @param args
*/
    public static void main(String[] args) {
    int[] a = {11,7,22,33,99,225,44,66,55,66,87,7};
    int[] b = {11,7,22,33,99,225,44,66,55,66,87,7};
    // 将数组转换为一个字符串
    System.out.println(Arrays.toString(a));
    // 排序
    // Arrays.sort(a);
    // 指定某个范围内的数据排序
    //Arrays.sort(a, 3, 8);
    System.out.println(Arrays.toString(a));
    // 二分查找
    int index = Arrays.binarySearch(a, 661);
    System.out.println(index);
    // 判断两个数组是否相等
    System.out.println(Arrays.equals(a, b));
    // 给数组中的元素填充内容
    // Arrays.fill(a, 1);
    // 局部填充
    Arrays.fill(a, 2, 5, 1);
    System.out.println(Arrays.toString(a));
    // 复制数组
    int[] c = Arrays.copyOf(a, a.length-2);
    System.out.println(Arrays.toString(c));
    // 指定范围复制
    int d[] = Arrays.copyOfRange(a, 3, 7);
    System.out.println(Arrays.toString(d));
    }
}
```



## 二维数组

### 定义语法

```java
//1
int[][] arr = new int[m][n];
//2
int arr[][] = new int[m][n];
//3
int[] arr[] = new int[m][n];
/**
*其中的n是可选的
*/
```

### 内存示意图

```java
int[][] array = new array[3][2];
array[0][0] = 1;
array[0][1] = 2;
array[1][0] = 3;
array[1][1] = 4;
array[2][0] = 5;
array[2][1] = 6;
```

![二维数组内存示意图](img\二维数组内存示意图.png)

### 自由的二维数组

``` java
int[][] array = new int[3][];
array[0] = new int[2];
array[1] = new int[3];
array[2] = new int[4];
```

> _array of address_ 或许是高维数组更为贴切的描述

### 二维数组的遍历

```java
public static void arrayPrintToString(int[][] arr) {
    for (int i = 0; i < arr.length; i++) {
        for (int j = 0; j < arr[i].length; j++) {
            System.out.println(arr[i][j]);
        }
    }
}
//foreach version
public static void arrayPrintToString(int[] ... arr){
    for(int[] x : arr){
        for(int y : x){
            System.out.print(y + "\t");
        }
    	System.out.println();
    }
}
```