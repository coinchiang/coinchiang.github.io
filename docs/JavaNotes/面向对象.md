# 面向对象

## 面向对象的特征

- 封装
- 继承
- 多态
- 抽象

## 类的基本要素

 ```java
 访问权限修饰符 类名 {
     成员变量
     构造方法（有参、无参）
     成员方法（getters、setters）
 }
 ```

## 局部变量和成员变量

> 局部变量是指定义在方法中的变量

- 成员变量存储在堆内存中，局部变量存储在栈内存中
- 成员变量的生命周期与对象相同，局部变量的生命周期与方法相同
- 当局部变量和成员变量重名时，局部变量优先与成员变量（**就近原则**）

## 值传递和引用传递

> 实质上，数据的传递方式是复制

向方法传入基本数据类型的数据，方法得到的是该数据的副本；向方法传入引用数据类型的数据，方法得到的是该数据地址的副本。二者没有本质区别。

## 匿名对象

没有名字的对象称为匿名对象，该对象的使用具有一次性，也不需要有名字。

```java
PersonTools.showInfo(new Student());
```

## 构造方法

```java
访问权限修饰符 类名() {
    ...
}
```

- 默认存在无参构造方法，一旦我们添加构造方法，则默认无参构造方法将消失

- 通过`this`关键字可以实现构造方法相互调用，但是只能放置在构造方法的第一行

  ```java
  public class Student {
      private String name;
      private String studentID;
      private String gender;
      //无参构造方法
      public Student() {
          
      }
      //有参构造方法
      public Student(String name, String studentID) {
          this.name = name;
          this.studentID = studentID;
      }
      //重载
      public Student(String name, String studentID, String gender) {
          this(name, studentID);
          this.gender = gender;
      }
  }
  ```

## static

> `static`修饰的内容属于类而非对象

`Math.random()`

- 访问静态成员的方式

  ```java
  Class.method();
  Class.field;
  ```

- 静态环境下不能出现`this`和`super`关键字

- 工具类中常用`static`

## 代码块

声明：本节内容为鄙人对CSDN博主「insping」的[原创文章](https://blog.csdn.net/hspingcc/article/details/54893853)的不当摘抄。

#### 静态代码块

>静态代码块：在类中使用static修饰,并使用`{}`括起来的代码片段，用于**静态变量**的初始化或对象创建前的环境初始化，**只会被执行一次（第一次加载此类时执行）**，静态代码块优先于构造代码块执行

### 构造代码块

> 在类中没与任何的前缀或后缀,并使用`{}`括起来的代码片段

```java
public class Client {
    {	//构造代码块
        System.out.println("执行构造代码块");
    }

    public Client() {
        System.out.println("执行无参构造函数");
    }

    public Client(String string) {
        System.out.println("执行有参构造函数");
    }
}
```

代码块不具有独立执行的能力,编译器会把构造代码块插入到**每个**构造函数的最前端

```java
public class Client {

    public Client() {
        System.out.println("执行构造代码块");
        System.out.println("执行无参构造函数");
    }

    public Client(String string) {
        System.out.println("执行构造代码块");
        System.out.println("执行有参构造函数");
    }
}
```

由于是插入到构造函数的的前面,自然在通过`new`关键字生成一个实例的时候会先执行构造代码块，然后再执行其他代码（**构造代码块不是在构造函数之前运行,而是依托于构造函数**）。

所以构造代码块具有如下特性：

1. 在每个构造函数中都运行
2.  在构造函数中它会首先运行

应用于：

1. 初始化__实例__变量

   > 如果每个构造函数都需要初始化变量,即可通过构造代码块来实现.从而取代在每个构造函数调用初始化实例变量的方法

2. 初始化**实例**环境

   > 一个对象必须在适当的场景下才能存在,如果没有适当的场景,则就需要在创建对象的时候创建此场景

### 构造代码块足够聪明

```java
//用构造代码块做对象计数器
public class Client {
    public static int count = 0;
    {
        count++;
    }

    public Client() {

    }

    public Client(int i) {
        this();
    }

    public Client(String string) {
    }

    public static void main(String[] args) {
        new Client();
        new Client(1);
        new Client("1");
        System.out.println(Client.count);
    }
}
```

这个代码真的达到我们预期的效果：结果是`3`。你可能会对`this()`产生质疑。

Java编译器是足够聪明的。这是因为，在插入到每个构造函数中的时候，有个例外，就是如果遇到`this()`方法（也就是构造函数调用自身其他的构造函数时）不插入构造代码块 。

那为什么编译器这么聪明呢？这是因为构造代码块的出现本就是为了提取构造函数的共同量，减少各个构造函数的代码而产生的。

灵活适当的使用构造代码块会让你的代码更加的简约和清晰。代码的质量自然会高很多。

最后还有一点需要注意的,千万不要认为`this()`是特殊情况,那`super()`也会类似处理。其实不会，在构造代码块的处理上，`super()`方法没有任何特殊的地方。编译器只是把构造代码块插入到 `super()`方法**之后**执行而已。

###  静态代码块和构造方法的执行顺序

`父类`

```java
package com.xanadu.exercise;

public class UntitledFather {
	private String familyName;
	static String country;
	
	public UntitledFather() {
		System.out.println("执行父类构造方法");
	}
	
	static {
		country = "China";
		System.out.println("执行父类静态代码块");
	}
}
```

`子类`

```java
package com.xanadu.exercise;

public class UntitledSon extends UntitledFather {
	public UntitledSon() {
		System.out.println("执行子类的构造方法");
	}
	
	static {
		System.out.println("执行子类的静态代码块");
	}
}
```

`测试类`

```java
package com.xanadu.exercise;

public class TestForUntitled {
	public static void main(String[] args) {
		UntitledSon u1 = new UntitledSon();
		UntitledSon u2 = new UntitledSon();
	}
}
```

`输出`

```java
执行父类静态代码块
执行子类的静态代码块
执行父类构造方法
执行子类的构造方法
执行父类构造方法
执行子类的构造方法
```

## package import

> `package`的本质就是文件夹

1. 在同一个包下面的类可以直接使用 

2. 在Java中`java.lang`包下面的所有的类可以直接使用

3. 除了以上两种其他类的使用都必须通过`import`关键字来导入才可以使用

4. 如果一个类没有包名，那么该类将不会被其他包所导入

5. 包的声明必须出现在第一句

6. `package`语句在一个java文件中只能出现一句

7. 如果一个类文件需要使用到两个包下同名的类，一个通过`import`来导入，另一个通过代码中全路径指定的方式来实现

   ```java
   com.xanadu.oop.Student student = new com.xanadu.oop.Student();
   ```

## 继承

1. 继承是对一批类的抽象，类是对一批对象的抽象 

2. Java中只支持单继承，不支持多继承，但是支持多层继承

3. 子类可以继承父类`private`修饰的属性和方法，但是不可见

   > `super`是不能访问私有的成员变量的，可以通过访问对应的公有方法实现

   ![image-20220203220419259](img\继承private属性.png)

4. 子类不可以继承父类构造方法

5. 任何一个构造方法都默认的会在构造方法的第一句上写上`super()`访问父类的无参构造方法，目的是初始化父类的成员变量

6. `super()`和`this()`方法构造方法都必须出现在构造方法的第一句，`this()`和`super()`在方法构造方法的时候，不能共存

   ![image-20220203221536404](img\this和super.png)

7. `static`的上下文都是不能出现`this`和`super`的，因为`static`是类的

## 访问权限修饰符

> `public` `protected` `[default]` `private`

### 修饰的元素

- 类：
  - 只有`public`、`abstract`和`final`能够修饰，或者不加（`default`）
  - `private`和`protected`可以修饰*内部类*
- 成员变量
- 成员方法

### 权限的范围

按由宽到严的顺序：

1. `public`修饰的成员对一切类可见 
2. `protected`修饰的成员同包下面都可见，不同包下只有**子类**可见
3. `default`修饰的成员仅同包下可见
4. `private`修饰的成员仅对本类可见

## 方法的重写

> 如果从父类继承的方法不能满足子类的需求的情况下，可以对其进行改写，称为方法的重写

方法的重写的规则

- 方法名称相同
- 参数列表相同
- 返回值类型相同或者是其**子类**
- 访问权限修饰符**不严于**父类